package com.flight.service.service;

import java.time.LocalDate;
import java.time.LocalDateTime;

import org.springframework.stereotype.Service;

import com.flight.service.client.AirlineClient;
import com.flight.service.entity.AIRPORT_CODE;
import com.flight.service.entity.Flight;
import com.flight.service.exception.BusinessException;
import com.flight.service.exception.NotFoundException;
import com.flight.service.repository.FlightRepository;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Service
public class FlightServiceImpl implements FlightService {

	private static final int CANCELLATION_LIMIT_HOURS = 24;

    private final FlightRepository flightRepo;
    private final BookingRepository bookingRepo;
    private final PassengerRepository passengerRepo;

    private final AirlineClient airlineClient;
    private final UserClient userClient;

    public FlightServiceReactiveImpl(
            FlightRepository flightRepo,
            BookingRepository bookingRepo,
            PassengerRepository passengerRepo,
            AirlineClient airlineClient,
            UserClient userClient) {

        this.flightRepo = flightRepo;
        this.bookingRepo = bookingRepo;
        this.passengerRepo = passengerRepo;
        this.airlineClient = airlineClient;
        this.userClient = userClient;
    }

//    @Override
//    public Mono<Flight> addFlight(Flight flight) {
//
//        // simple validations (airline existence will be via airline-service later if needed)
//        if (flight.getFromCity().equals(flight.getToCity())) {
//            return Mono.error(new BusinessException("source and destination must be different"));
//        }
//        if (flight.getArrivalTime().isBefore(flight.getDepartureTime())) {
//            return Mono.error(new BusinessException("arrival time must be after departure time"));
//        }
//        if (flight.getDepartureTime().isBefore(LocalDateTime.now())) {
//            return Mono.error(new BusinessException("Flight departure time must be in the future"));
//        }
//
//        // initialize availableSeats = totalSeats
//        flight.setAvailableSeats(flight.getTotalSeats());
//
//        return flightRepo.save(flight);
//    }
    @Override
    public Mono<Flight> addFlight(Flight flight) {

        return Mono.fromCallable(() -> airlineClient.getAirline(flight.getAirlineCode()))
                .subscribeOn(Schedulers.boundedElastic())
                .onErrorResume(e -> Mono.error(new NotFoundException("Airline service unavailable")))
                .flatMap(airline -> {
                    // airline not found from airline-service
                    if (airline.getCode() == null || airline.getName() == null) {
                        return Mono.error(new NotFoundException("Airline not found"));
                    }

                    // VALIDATION 1: from != to
                    if (flight.getFromCity().equals(flight.getToCity())) {
                        return Mono.error(new BusinessException("source and destination must be different"));
                    }

                    // VALIDATION 2: arrival must be after departure
                    if (flight.getArrivalTime().isBefore(flight.getDepartureTime())) {
                        return Mono.error(new BusinessException("arrival time must be after departure time"));
                    }

                    // VALIDATION 3: departure must be in the future
                    if (flight.getDepartureTime().isBefore(LocalDateTime.now())) {
                        return Mono.error(new BusinessException("Flight departure time must be in the future"));
                    }

                    // Set available seats
                    flight.setAvailableSeats(flight.getTotalSeats());

                    return flightRepo.save(flight);
                });
    }

    @Override
    public Flux<Flight> searchFlights(AIRPORT_CODE from, AIRPORT_CODE to, LocalDate date) {
        return flightRepo.findByFromCityAndToCity(from, to)
                .filter(f -> f.getDepartureTime().toLocalDate().equals(date));
    }

    @Override
    public Mono<Flight> getFlightById(String flightId) {
        return flightRepo.findById(flightId)
                .switchIfEmpty(Mono.error(new NotFoundException("Flight not found")));
    }

    @Override
    public Flux<Flight> getFlightsByAirline(String airlineCode) {
        return flightRepo.findByAirlineCode(airlineCode);
    }
}
