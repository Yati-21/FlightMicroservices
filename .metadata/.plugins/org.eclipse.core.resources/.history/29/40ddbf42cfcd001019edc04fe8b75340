package com.flight.service;

import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;

import org.springframework.stereotype.Service;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.scheduling.annotation.Async;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.beans.factory.annotation.Autowired;

import com.flight.client.AirlineClient;
import com.flight.client.UserClient;
import com.flight.entity.AIRPORT_CODE;
import com.flight.entity.Booking;
import com.flight.entity.Flight;
import com.flight.entity.Passenger;
import com.flight.exception.BusinessException;
import com.flight.exception.NotFoundException;
import com.flight.exception.SeatUnavailableException;
import com.flight.repository.BookingRepository;
import com.flight.repository.FlightRepository;
import com.flight.repository.PassengerRepository;
import com.flight.request.BookingRequest;
import com.flight.request.PassengerRequest;

import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

@Slf4j
@Service
public class FlightServiceReactiveImpl implements FlightServiceReactive {

    private static final int CANCELLATION_LIMIT_HOURS = 24;

    private final FlightRepository flightRepo;
    private final BookingRepository bookingRepo;
    private final PassengerRepository passengerRepo;

    private final AirlineClient airlineClient;
    private final UserClient userClient;

    public FlightServiceReactiveImpl(
            FlightRepository flightRepo,
            BookingRepository bookingRepo,
            PassengerRepository passengerRepo,
            AirlineClient airlineClient,
            UserClient userClient) {

        this.flightRepo = flightRepo;
        this.bookingRepo = bookingRepo;
        this.passengerRepo = passengerRepo;
        this.airlineClient = airlineClient;
        this.userClient = userClient;
    }


    // =======================
    //     ADD NEW FLIGHT
    // =======================
    @Override
    @CircuitBreaker(name = "airlineServiceCB", fallbackMethod = "addFlightFallback")
    public Mono<Flight> addFlight(Flight flight) {

        return Mono.fromCallable(() -> airlineClient.getAirline(flight.getAirlineCode()))
                .subscribeOn(Schedulers.boundedElastic())
                .onErrorResume(e -> Mono.error(new NotFoundException("Airline service unavailable")))
                .flatMap(airline -> {

                    if (airline.getCode() == null)
                        return Mono.error(new NotFoundException("Airline not found"));

                    if (flight.getFromCity().equals(flight.getToCity()))
                        return Mono.error(new BusinessException("source and destination must be different"));

                    if (flight.getArrivalTime().isBefore(flight.getDepartureTime()))
                        return Mono.error(new BusinessException("arrival time must be after departure time"));

                    if (flight.getDepartureTime().isBefore(LocalDateTime.now()))
                        return Mono.error(new BusinessException("Flight departure time must be in the future"));

                    flight.setAvailableSeats(flight.getTotalSeats());

                    return flightRepo.save(flight);
                });
    }

    // fallback
    public Mono<Flight> addFlightFallback(Flight flight, Throwable ex) {
        return Mono.error(new BusinessException("Airline service DOWN. Cannot validate airline"));
    }


    // =======================
    //   SEARCH FLIGHTS
    // =======================
    @Override
    public Flux<Flight> searchFlights(AIRPORT_CODE from, AIRPORT_CODE to, LocalDate date) {
        return flightRepo.findByFromCityAndToCity(from, to)
                .filter(f -> f.getDepartureTime().toLocalDate().equals(date));
    }


    // =======================
    //   GET FLIGHT BY ID
    // =======================
    @Override
    public Mono<Flight> getFlightById(String flightId) {
        return flightRepo.findById(flightId)
                .switchIfEmpty(Mono.error(new NotFoundException("Flight not found")));
    }


    // =======================
    //      BOOK TICKET
    // =======================
    @Override
    @CircuitBreaker(name = "userServiceCB", fallbackMethod = "bookTicketFallback")
    public Mono<String> bookTicket(String flightId, BookingRequest request) {

        // USER VALIDATION VIA USER-SERVICE (Feign)
        Mono<Void> userCheck = Mono.fromCallable(() -> userClient.getUser(request.getUserId()))
                .subscribeOn(Schedulers.boundedElastic())
                .onErrorResume(e -> Mono.error(new NotFoundException("User not found")))
                .then();

        return userCheck.then(
                flightRepo.findById(flightId)
                        .switchIfEmpty(Mono.error(new NotFoundException("Flight not found")))
                        .flatMap(flight -> {

                            if (request.getPassengers().size() != request.getSeatsBooked())
                                return Mono.error(new BusinessException("Passengers count must be equal to seats booked"));

                            if (flight.getAvailableSeats() < request.getSeatsBooked())
                                return Mono.error(new SeatUnavailableException("Not enough seats available"));

                            validatePassengerDuplicateRequest(request.getPassengers());

                            // seat conflict check
                            return checkSeatConflicts(flightId, request.getPassengers())
                                    .then(saveNewBooking(flight, request));
                        })
        );
    }

    // fallback
    public Mono<String> bookTicketFallback(String flightId, BookingRequest request, Throwable ex) {
        return Mono.error(new BusinessException("User service DOWN. Cannot validate user."));
    }


    // ===========================================
    //      SAVE BOOKING + SAVE PASSENGERS
    // ===========================================
    private Mono<String> saveNewBooking(Flight flight, BookingRequest req) {

        String pnr = generateRandomPNR();

        Booking booking = new Booking();
        booking.setPnr(pnr);
        booking.setFlightId(flight.getId());
        booking.setUserId(req.getUserId());
        booking.setSeatsBooked(req.getSeatsBooked());
        booking.setMealType(req.getMealType());
        booking.setFlightType(req.getFlightType());
        booking.setPassengerIds(new ArrayList<>());

        return bookingRepo.save(booking)
                .flatMap(savedBooking ->
                        savePassengers(savedBooking.getId(), req.getPassengers())
                                .flatMap(ids -> {

                                    savedBooking.setPassengerIds(ids);
                                    flight.setAvailableSeats(flight.getAvailableSeats() - req.getSeatsBooked());

                                    return bookingRepo.save(savedBooking)
                                            .then(flightRepo.save(flight))
                                            .thenReturn(savedBooking.getPnr());
                                }));
    }


    private Mono<List<String>> savePassengers(String bookingId, List<PassengerRequest> list) {

        return Flux.fromIterable(list)
                .flatMap(req -> {
                    Passenger p = new Passenger();
                    p.setName(req.getName());
                    p.setGender(req.getGender());
                    p.setAge(req.getAge());
                    p.setSeatNumber(req.getSeatNumber());
                    p.setBookingId(bookingId);
                    return passengerRepo.save(p);
                })
                .map(Passenger::getId)
                .collectList();
    }


    // =======================
    //        GET TICKET
    // =======================
    @Override
    public Mono<Booking> getTicket(String pnr) {
        return bookingRepo.findByPnr(pnr)
                .switchIfEmpty(Mono.error(new NotFoundException("PNR not found")));
    }


    // ================================
    //  BOOKING HISTORY - USER ID
    // ================================
    @Override
    public Flux<Booking> getBookingHistoryByUserId(String userId) {
        return bookingRepo.findByUserId(userId);
    }


    // =======================
    //      CANCEL BOOKING
    // =======================
    @Override
    public Mono<Void> cancelBooking(String pnr) {

        return bookingRepo.findByPnr(pnr)
                .switchIfEmpty(Mono.error(new NotFoundException("Invalid PNR")))
                .flatMap(booking -> flightRepo.findById(booking.getFlightId())
                        .flatMap(flight -> {

                            long hrs = Duration.between(LocalDateTime.now(), flight.getDepartureTime()).toHours();

                            if (hrs < CANCELLATION_LIMIT_HOURS)
                                return Mono.error(new BusinessException("Cannot cancel within 24 hours of departure"));

                            flight.setAvailableSeats(flight.getAvailableSeats() + booking.getSeatsBooked());

                            return passengerRepo.deleteByBookingId(booking.getId())
                                    .then(bookingRepo.delete(booking))
                                    .then(flightRepo.save(flight))
                                    .then();
                        }));
    }


    // =================================
    //   BOOKING HISTORY - EMAIL
    // =================================
    @Override
    public Flux<Booking> getBookingHistoryByEmail(String email) {

        return Mono.fromCallable(() -> userClient.getUserByEmail(email))
                .subscribeOn(Schedulers.boundedElastic())
                .onErrorResume(e -> Mono.error(new NotFoundException("User not found with email: " + email)))
                .flatMapMany(user -> bookingRepo.findByUserId(user.getId()));
    }


    // =======================
    //   GET FLIGHTS BY AIRLINE
    // =======================
    @Override
    public Flux<Flight> getFlightsByAirline(String airlineCode) {
        return flightRepo.findByAirlineCode(airlineCode);
    }


    // =======================
    //  SEAT CONFLICT CHECK
    // =======================
    private Mono<Void> checkSeatConflicts(String flightId, List<PassengerRequest> passengers) {

        return bookingRepo.findByFlightId(flightId)
                .flatMap(b -> passengerRepo.findByBookingId(b.getId()))
                .map(Passenger::getSeatNumber)
                .collectList()
                .flatMap(existing -> {

                    for (PassengerRequest p : passengers)
                        if (existing.contains(p.getSeatNumber()))
                            return Mono.error(new SeatUnavailableException("Seat already booked: " + p.getSeatNumber()));

                    return Mono.empty();
                });
    }


    // =======================
    //  DUPLICATE SEAT CHECK
    // =======================
    private void validatePassengerDuplicateRequest(List<PassengerRequest> list) {

        Set<String> seats = new HashSet<>();

        for (PassengerRequest p : list)
            if (!seats.add(p.getSeatNumber()))
                throw new BusinessException("Duplicate seat in request: " + p.getSeatNumber());
    }


    // =======================
    //       RANDOM PNR
    // =======================
    private String generateRandomPNR() {
        return "PNR" + UUID.randomUUID().toString().substring(0, 8).toUpperCase();
    }

}


//package com.flight.service.service;
//
//import java.time.LocalDate;
//import java.time.LocalDateTime;
//
//import org.springframework.stereotype.Service;
//
//import com.flight.service.entity.AIRPORT_CODE;
//import com.flight.service.entity.Flight;
//import com.flight.service.exception.BusinessException;
//import com.flight.service.exception.NotFoundException;
//import com.flight.service.repository.FlightRepository;
//
//import reactor.core.publisher.Flux;
//import reactor.core.publisher.Mono;
//
//@Service
//public class FlightServiceImpl implements FlightService {
//
//    private final FlightRepository flightRepo;
//
//    public FlightServiceImpl(FlightRepository flightRepo) {
//        this.flightRepo = flightRepo;
//    }
//
////    @Override
////    public Mono<Flight> addFlight(Flight flight) {
////
////        // simple validations (airline existence will be via airline-service later if needed)
////        if (flight.getFromCity().equals(flight.getToCity())) {
////            return Mono.error(new BusinessException("source and destination must be different"));
////        }
////        if (flight.getArrivalTime().isBefore(flight.getDepartureTime())) {
////            return Mono.error(new BusinessException("arrival time must be after departure time"));
////        }
////        if (flight.getDepartureTime().isBefore(LocalDateTime.now())) {
////            return Mono.error(new BusinessException("Flight departure time must be in the future"));
////        }
////
////        // initialize availableSeats = totalSeats
////        flight.setAvailableSeats(flight.getTotalSeats());
////
////        return flightRepo.save(flight);
////    }
//    @Override
//    public Mono<Flight> addFlight(Flight flight) {
//
//        return Mono.fromCallable(() -> airlineClient.getAirline(flight.getAirlineCode()))
//                .subscribeOn(Schedulers.boundedElastic())
//                .onErrorResume(e -> Mono.error(new NotFoundException("Airline service unavailable")))
//                .flatMap(airline -> {
//                    // airline not found from airline-service
//                    if (airline.getCode() == null || airline.getName() == null) {
//                        return Mono.error(new NotFoundException("Airline not found"));
//                    }
//
//                    // VALIDATION 1: from != to
//                    if (flight.getFromCity().equals(flight.getToCity())) {
//                        return Mono.error(new BusinessException("source and destination must be different"));
//                    }
//
//                    // VALIDATION 2: arrival must be after departure
//                    if (flight.getArrivalTime().isBefore(flight.getDepartureTime())) {
//                        return Mono.error(new BusinessException("arrival time must be after departure time"));
//                    }
//
//                    // VALIDATION 3: departure must be in the future
//                    if (flight.getDepartureTime().isBefore(LocalDateTime.now())) {
//                        return Mono.error(new BusinessException("Flight departure time must be in the future"));
//                    }
//
//                    // Set available seats
//                    flight.setAvailableSeats(flight.getTotalSeats());
//
//                    return flightRepo.save(flight);
//                });
//    }
//
//    @Override
//    public Flux<Flight> searchFlights(AIRPORT_CODE from, AIRPORT_CODE to, LocalDate date) {
//        return flightRepo.findByFromCityAndToCity(from, to)
//                .filter(f -> f.getDepartureTime().toLocalDate().equals(date));
//    }
//
//    @Override
//    public Mono<Flight> getFlightById(String flightId) {
//        return flightRepo.findById(flightId)
//                .switchIfEmpty(Mono.error(new NotFoundException("Flight not found")));
//    }
//
//    @Override
//    public Flux<Flight> getFlightsByAirline(String airlineCode) {
//        return flightRepo.findByAirlineCode(airlineCode);
//    }
//}
